import os
import fitz  # PyMuPDF
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from mistralai import Mistral  # ‚úÖ Tu versi√≥n original que funciona
from openpyxl import load_workbook
from openpyxl.cell.cell import MergedCell
import time
import random
import re
import streamlit as st
import tempfile
import pandas as pd
import io  # ‚úÖ OCR: Import necesario
from PIL import Image  # ‚úÖ OCR: Import necesario
import pytesseract  # ‚úÖ OCR: Import necesario

# =========================
# CONFIGURACI√ìN
# =========================
st.set_page_config(page_title="Analizador de P√≥lizas + OCR", page_icon="üìã", layout="wide")

EMBED_MODEL = "mistral-embed"
LLM_MODEL = "mistral-small-latest"

# Configuraci√≥n de columnas Excel
FILA_INICIO = 17
COL_A = 1  # Columna con categor√≠as/t√©rminos
COL_B = 2  # Columna con descripciones
COL_G = 7  # Columna para respuestas PDF 1
COL_H = 8  # Columna para respuestas PDF 2
COL_I = 9  # ‚úÖ OCR: Nueva columna para respuestas OCR (opcional)
COL_F = 6  # Columna para indicar documento (opcional)

# Configuraci√≥n optimizada para velocidad
PAUSA_ENTRE_CONSULTAS = 0.5
MAX_REINTENTOS = 2

# Cache para embeddings (ahora por documento)
embeddings_cache_pdf1 = {}
embeddings_cache_pdf2 = {}
embeddings_cache_ocr = {}  # ‚úÖ OCR: Cache para documento con OCR

# =========================
# ‚úÖ OCR: FUNCI√ìN INTELIGENTE DE EXTRACCI√ìN (REEMPLAZA TU FUNCI√ìN ORIGINAL)
# =========================
def extraer_texto_pdf(path):
    """
    Extrae texto con detecci√≥n autom√°tica:
    - Si tiene texto nativo ‚Üí extracci√≥n directa (0.02s/p√°gina)
    - Si es escaneado ‚Üí OCR optimizado (1.8s/p√°gina)
    """
    doc = fitz.open(path)

    # Detectar si es PDF escaneado (sin texto en primeras 3 p√°ginas)
    tiene_texto_nativo = False
    for i in range(min(3, len(doc))):
        if doc[i].get_text().strip():
            tiene_texto_nativo = True
            break

    if tiene_texto_nativo:
        # ‚úÖ Extracci√≥n nativa R√ÅPIDA (tu c√≥digo original)
        texto = ""
        for page in doc:
            texto += page.get_text() + "\n\n"
        doc.close()
        return texto.strip()

    # ‚úÖ OCR SOLO si es necesario (PDF 100% imagen)
    st.info(f"üñºÔ∏è PDF detectado como escaneado. Aplicando OCR optimizado (dpi=200)...")
    texto = ""
    for page_num in range(len(doc)):
        pix = doc[page_num].get_pixmap(dpi=200)  # dpi=200 = velocidad √≥ptima
        img = Image.open(io.BytesIO(pix.tobytes()))
        texto_pagina = pytesseract.image_to_string(
            img,
            lang="spa+eng",
            config="--oem 1 --psm 6"  # OEM 1 = LSTM r√°pido (m√°ximo rendimiento)
        )
        texto += f"\n--- P√ÅGINA {page_num + 1} ---\n" + texto_pagina + "\n\n"
    doc.close()
    return texto.strip()

# =========================
# INICIALIZACI√ìN MISTRAL (SIN CAMBIOS - TU C√ìDIGO ORIGINAL)
# =========================
def inicializar_mistral():
    """Inicializa el cliente Mistral con API key de secrets o input"""
    if 'mistral_client' not in st.session_state:
        # Intentar obtener de secrets.toml primero
        try:
            api_key = st.secrets.get("MISTRAL_API_KEY", "")
        except:
            api_key = ""

        # Si no hay en secrets, pedir al usuario
        if not api_key:
            api_key = st.text_input("üîë Ingresa tu API Key de Mistral:", type="password", key="api_key_input")
            if not api_key:
                st.warning("Por favor, ingresa tu API Key de Mistral para continuar.")
                return None

        try:
            st.session_state.mistral_client = Mistral(api_key=api_key)
            st.success("‚úÖ Cliente Mistral inicializado correctamente")
        except Exception as e:
            st.error(f"‚ùå Error al inicializar Mistral: {str(e)}")
            return None

    return st.session_state.mistral_client

# =========================
# FUNCIONES PARA EXCEL (SIN CAMBIOS)
# =========================
def valor_real(ws, celda):
    """Obtiene el valor real de una celda, manejando celdas fusionadas"""
    if not isinstance(celda, MergedCell):
        return celda.value
    for r in ws.merged_cells.ranges:
        if celda.coordinate in r:
            return ws.cell(r.min_row, r.min_col).value
    return None

def construir_vector(ws):
    """Construye un vector con las filas y textos a procesar del Excel"""
    vector = []
    for row in range(FILA_INICIO, ws.max_row + 1):
        a = valor_real(ws, ws.cell(row=row, column=COL_A))
        b = ws.cell(row=row, column=COL_B).value

        # Solo procesar filas con contenido en columna A
        if a and str(a).strip():
            texto = f"{a} {b}".strip() if b else str(a)
            vector.append((row, texto))

    return vector

def escribir_en_celda(ws, row, col, valor):
    """Escribe un valor en una celda, manejando celdas fusionadas"""
    celda = ws.cell(row=row, column=col)

    if not isinstance(celda, MergedCell):
        celda.value = valor
        return

    for r in ws.merged_cells.ranges:
        if celda.coordinate in r:
            ws.cell(r.min_row, r.min_col).value = valor
            return

# =========================
# FUNCIONES PARA PDF (RAG) - SIN CAMBIOS EN L√ìGICA
# =========================
def dividir_texto(texto, chunk_size=1800, overlap=250):
    """Divide el texto en chunks para procesamiento"""
    chunks = []
    start = 0
    while start < len(texto):
        end = start + chunk_size
        chunks.append(texto[start:end])
        start = end - overlap
    return chunks

def generar_embeddings_con_reintentos(textos, client):
    """Genera embeddings con reintentos optimizados"""
    if isinstance(textos, str):
        textos = [textos]

    for intento in range(MAX_REINTENTOS + 1):
        try:
            response = client.embeddings.create(
                model=EMBED_MODEL,
                inputs=textos
            )
            return np.array([e.embedding for e in response.data])
        except Exception as e:
            if intento < MAX_REINTENTOS and ("rate_limited" in str(e) or "429" in str(e)):
                espera = (2 ** intento) * 0.5 + random.uniform(0.5, 1.5)
                time.sleep(espera)
            else:
                raise e

    raise Exception(f"‚ùå Error despu√©s de {MAX_REINTENTOS} reintentos")

def buscar_contexto(pregunta, chunks, embeddings, embeddings_cache, client, top_k=5, umbral=0.15):
    """Busca contexto relevante optimizado"""

    # Cache para embeddings de preguntas (por documento)
    if pregunta not in embeddings_cache:
        embeddings_cache[pregunta] = generar_embeddings_con_reintentos([pregunta], client)[0]

    emb_q = embeddings_cache[pregunta].reshape(1, -1)

    # Calcular similitudes
    sims = cosine_similarity(emb_q, embeddings)[0]
    idx = sims.argsort()[::-1]

    # Seleccionar chunks relevantes m√°s r√°pido
    seleccion = []
    for i in idx[:top_k*2]:
        if sims[i] >= umbral or len(seleccion) < 2:
            seleccion.append(chunks[i])
        if len(seleccion) == top_k:
            break

    return seleccion

# =========================
# DICCIONARIO MEJORADO DE T√âRMINOS DE SEGUROS (SIN CAMBIOS)
# =========================
TERMINOS_SEGUROS = {
    # T√âRMINOS DE MODALIDAD/TIPO DE P√ìLIZA
    "modalidad": ["modalidad", "tipo de p√≥liza", "sistema", "modelo", "forma", "tipo", "clase", "categor√≠a"],
    "mixto": ["mixto", "combinado", "h√≠brido", "mixta"],
    "abierto": ["sistema abierto", "abierto", "libre elecci√≥n", "elecci√≥n libre"],
    "cerrado": ["sistema cerrado", "cerrado", "red cerrada", "proveedores espec√≠ficos"],

    # T√âRMINOS GEOGR√ÅFICOS/COBERTURA TERRITORIAL
    "alcance de la cobertura": ["cobertura geogr√°fica", "√°mbito geogr√°fico", "alcance territorial",
                   "cobertura territorial", "√°mbito de cobertura", "zona de cobertura"],
    "nacional": ["nacional", "todo el pa√≠s", "en todo bolivia", "a nivel nacional"],
    "internacional": ["internacional", "en el extranjero", "fuera del pa√≠s", "cobertura internacional"],
    "departamentos": ["departamentos", "regiones", "provincias", "ciudades"],

    # T√âRMINOS DE COBERTURA
    "cobertura": ["cobertura", "protecci√≥n", "amparo", "beneficio", "garant√≠a", "inclusi√≥n"],
    "capital": ["capital asegurado", "monto asegurado", "suma asegurada", "valor asegurado",
                "l√≠mite", "importe", "cantidad", "capital"],
    "prima": ["prima", "precio", "costo", "tarifa", "valor", "cuota"],
    "deducible": ["deducible", "franquicia", "copago", "participaci√≥n"],

    # T√âRMINOS ESPEC√çFICOS DE SERVICIOS
    "reembolso": ["reembolso", "devoluci√≥n", "pago", "compensaci√≥n", "restituci√≥n"],
    "hospitalizaci√≥n": ["hospitalizaci√≥n", "internaci√≥n", "ingreso", "estancia hospitalaria"],
    "ambulatorio": ["ambulatorio", "consulta externa", "tratamiento ambulatorio"],
    "emergencia": ["emergencia", "urgencia", "accidente", "siniestro"],

    # T√âRMINOS DE EXCLUSIONES
    "exclusi√≥n": ["exclusi√≥n", "no cubre", "excluye", "no incluye", "excepto", "limitaci√≥n"],

    # T√âRMINOS DE ENFERMEDADES
    "covid": ["covid", "coronavirus", "pandemia", "enfermedad epid√©mica"],
    "maternidad": ["maternidad", "embarazo", "parto", "nacimiento", "control prenatal"],
    "parto": ["parto natural", "parto normal", "parto", "nacimiento"],
}

# =========================
# FUNCI√ìN PARA DETECTAR TIPO DE CONSULTA (SIN CAMBIOS)
# =========================
def detectar_tipo_consulta(pregunta):
    """Detecta el tipo de consulta para usar sin√≥nimos espec√≠ficos"""
    pregunta_lower = pregunta.lower()

    tipos_detectados = []

    for termino, sin√≥nimos in TERMINOS_SEGUROS.items():
        # Verificar si la pregunta contiene el t√©rmino o sus sin√≥nimos
        if any(s in pregunta_lower for s in [termino] + sin√≥nimos[:2]):
            tipos_detectados.append(termino)

    # Priorizar tipos espec√≠ficos
    if "modalidad" in tipos_detectados:
        return "MODALIDAD"
    elif "geogr√°fico" in tipos_detectados:
        return "COBERTURA_GEOGR√ÅFICA"
    elif "capital" in tipos_detectados:
        return "MONTO_CAPITAL"
    elif "reembolso" in tipos_detectados:
        return "REEMBOLSO"
    elif "cobertura" in tipos_detectados:
        return "COBERTURA_GENERAL"

    return "GENERAL"

# =========================
# LLM OPTIMIZADO CON DICCIONARIO MEJORADO (SIN CAMBIOS)
# =========================
def preguntar_llm_optimizada(pregunta, contexto, client):
    """LLM optimizado con diccionario mejorado de t√©rminos de seguros"""

    tipo_consulta = detectar_tipo_consulta(pregunta)

    # Obtener sin√≥nimos relevantes para esta consulta
    sinonimos_relevantes = []
    for termino, sin√≥nimos in TERMINOS_SEGUROS.items():
        if termino in pregunta.lower() or any(s in pregunta.lower() for s in sin√≥nimos[:3]):
            sinonimos_relevantes.extend(sin√≥nimos[:3])

    sinonimos_texto = ", ".join(set(sinonimos_relevantes[:6]))  # Limitar a 6 sin√≥nimos

    prompt = f"""
Eres experto en p√≥lizas de seguros. Analiza la siguiente consulta y busca informaci√≥n que coincida o similitudes.

DOCUMENTO DE LA P√ìLIZA:
{contexto}

CONSULTA: "{pregunta}"

TIPO DE CONSULTA DETECTADA: {tipo_consulta}
T√âRMINOS RELACIONADOS PARA B√öSQUEDA: {sinonimos_texto}

INSTRUCCIONES ESPEC√çFICAS PARA {tipo_consulta}:

{get_instrucciones_especificas(tipo_consulta)}

REGLAS GENERALES:
1. Busca por SIGNIFICADO, no solo por palabras exactas
2. Usa los t√©rminos relacionados para b√∫squeda ampliada
3. Copia EXACTAMENTE el texto relevante del documento
4. NO inventes, NO interpretes, NO resumas
5. Si no encuentras, responde EXACTAMENTE: "no encontrado"
6. NO agregues "Respuesta:", ni explicaciones, ni formato

EJEMPLOS CORRECTOS POR TIPO:
- MODALIDAD: "Mixto: sistema abierto y cerrado"
- ALCANCE_DE_COBERTURA: "Cobertura en 9 departamentos de Bolivia"
- MONTO_CAPITAL: "USD XX seg√∫n detalle"
- REEMBOLSO: "XX% en sistema abierto, XX% primeras 48 horas"

RESPUESTA DIRECTA DEL DOCUMENTO:
"""

    for intento in range(MAX_REINTENTOS + 1):
        try:
            response = client.chat.complete(
                model=LLM_MODEL,
                messages=[{"role": "user", "content": prompt}],
                temperature=0.1,
                max_tokens=150
            )

            respuesta = response.choices[0].message.content.strip()

            # Limpieza mejorada
            respuesta = clean_response(respuesta)

            return respuesta

        except Exception as e:
            if intento < MAX_REINTENTOS and ("rate_limited" in str(e) or "429" in str(e)):
                espera = (2 ** intento) * 0.3 + random.uniform(0.3, 1.0)
                time.sleep(espera)
            else:
                return "error"

    return "error: rate limit"

def get_instrucciones_especificas(tipo_consulta):
    """Devuelve instrucciones espec√≠ficas para cada tipo de consulta"""
    instrucciones = {
        "MODALIDAD": """
        ‚Ä¢ Busca t√©rminos: "modalidad", "tipo de p√≥liza", "sistema"
        ‚Ä¢ Especifica si es: mixto, abierto, cerrado, combinado
        ‚Ä¢ Incluye detalles del sistema de atenci√≥n
        """,

        "COBERTURA_GEOGR√ÅFICA": """
        ‚Ä¢ Busca t√©rminos: "cobertura geogr√°fica", "√°mbito", "departamentos", "nacional", "internacional"
        ‚Ä¢ Especifica zonas, regiones, pa√≠ses cubiertos
        ‚Ä¢ Menciona l√≠mites territoriales si existen
        """,

        "MONTO_CAPITAL": """
        ‚Ä¢ Busca t√©rminos: "capital", "monto", "suma", "valor", "USD", "Bs.", "l√≠mite"
        ‚Ä¢ Extrae n√∫meros exactos con su moneda
        ‚Ä¢ Incluye condiciones si las hay
        """,

        "REEMBOLSO": """
        ‚Ä¢ Busca t√©rminos: "reembolso", "porcentaje", "%", "cobertura", "pago"
        ‚Ä¢ Extrae porcentajes exactos y condiciones
        ‚Ä¢ Especifica plazos y modalidades
        """,

        "COBERTURA_GENERAL": """
        ‚Ä¢ Busca t√©rminos espec√≠ficos de la consulta
        ‚Ä¢ Extrae condiciones, l√≠mites, inclusiones
        ‚Ä¢ Especifica detalles relevantes
        """,

        "GENERAL": """
        ‚Ä¢ Busca informaci√≥n relacionada con la consulta
        ‚Ä¢ Usa t√©rminos equivalentes del sector
        ‚Ä¢ Extrae informaci√≥n precisa y relevante
        """
    }

    return instrucciones.get(tipo_consulta, instrucciones["GENERAL"])

def clean_response(respuesta):
    """Limpia la respuesta de forma robusta"""
    if not respuesta:
        return "no encontrado"

    # Convertir a min√∫sculas para comparaciones
    respuesta_lower = respuesta.lower()

    # Lista de patrones que indican "no encontrado"
    no_encontrado_patterns = [
        "no encontrado", "no se encuentra", "no existe", "no hay informaci√≥n",
        "no aparece", "no figura", "no se menciona", "no se halla",
        "informaci√≥n no disponible", "no disponible"
    ]

    for pattern in no_encontrado_patterns:
        if pattern in respuesta_lower:
            return "no encontrado"

    # Eliminar prefijos comunes
    prefixes_to_remove = [
        r'^respuesta[:\s]*',
        r'^resultado[:\s]*',
        r'^encontrado[:\s]*',
        r'^informaci√≥n[:\s]*',
        r'^\s*[-*‚Ä¢]\s*',
        r'^\s*\d+[\.\)]\s*'
    ]

    for prefix in prefixes_to_remove:
        respuesta = re.sub(prefix, '', respuesta, flags=re.IGNORECASE)

    # Eliminar formato
    respuesta = re.sub(r'\*\*.*?\*\*', '', respuesta)
    respuesta = re.sub(r'__.*?__', '', respuesta)

    # Normalizar espacios
    respuesta = re.sub(r'\s+', ' ', respuesta).strip()

    # Verificar longitud m√≠nima
    if len(respuesta) < 10 or len(respuesta.split()) < 3:
        return "no encontrado"

    # Limitar longitud m√°xima
    if len(respuesta) > 300:
        # Mantener la parte m√°s importante (buscar n√∫meros o t√©rminos clave)
        sentences = re.split(r'[.!?]', respuesta)
        for sentence in sentences:
            if re.search(r'[\d\.,]+', sentence) and len(sentence) > 20:
                respuesta = sentence.strip() + "."
                break

        if len(respuesta) > 300:
            respuesta = respuesta[:297] + "..."

    return respuesta

# =========================
# FUNCIONES DE PREPARACI√ìN PARA STREAMLIT
# =========================
def preparar_documento(pdf_path, client):
    """Prepara un documento PDF para b√∫squeda RAG"""
    # ‚úÖ Usa la funci√≥n inteligente con OCR integrado
    texto = extraer_texto_pdf(pdf_path)

    # Dividir en chunks
    chunks = dividir_texto(texto, chunk_size=2000, overlap=300)

    # Generar embeddings
    embeddings_list = []
    batch_size = 8

    for i in range(0, len(chunks), batch_size):
        batch = chunks[i:i+batch_size]
        try:
            batch_embeddings = generar_embeddings_con_reintentos(batch, client)
            embeddings_list.append(batch_embeddings)
            time.sleep(0.3)  # Pausa m√≠nima entre lotes
        except Exception:
            continue

    embeddings = np.vstack(embeddings_list) if embeddings_list else np.array([])

    return chunks, embeddings

def procesar_consulta_dual(fila, consulta, chunks1, embeddings1, chunks2, embeddings2, chunks_ocr, embeddings_ocr, client, usar_ocr):
    """Procesa una consulta en ambos PDFs + opcional OCR"""
    resultado = {'fila': fila, 'consulta': consulta}

    # Procesar con PDF 1
    try:
        contexto_chunks1 = buscar_contexto(consulta, chunks1, embeddings1, embeddings_cache_pdf1, client)
        if contexto_chunks1:
            contexto_texto1 = "\n\n".join(contexto_chunks1[:3])
            respuesta1 = preguntar_llm_optimizada(consulta, contexto_texto1, client)
        else:
            respuesta1 = "no encontrado"
    except Exception as e:
        respuesta1 = f"error: {str(e)[:50]}"

    # Procesar con PDF 2
    try:
        contexto_chunks2 = buscar_contexto(consulta, chunks2, embeddings2, embeddings_cache_pdf2, client)
        if contexto_chunks2:
            contexto_texto2 = "\n\n".join(contexto_chunks2[:3])
            respuesta2 = preguntar_llm_optimizada(consulta, contexto_texto2, client)
        else:
            respuesta2 = "no encontrado"
    except Exception as e:
        respuesta2 = f"error: {str(e)[:50]}"

    # ‚úÖ OCR: Procesar con documento OCR si est√° habilitado
    if usar_ocr and chunks_ocr is not None and len(embeddings_ocr) > 0:
        try:
            contexto_chunks3 = buscar_contexto(consulta, chunks_ocr, embeddings_ocr, embeddings_cache_ocr, client)
            if contexto_chunks3:
                contexto_texto3 = "\n\n".join(contexto_chunks3[:3])
                respuesta3 = preguntar_llm_optimizada(consulta, contexto_texto3, client)
            else:
                respuesta3 = "no encontrado"
        except Exception as e:
            respuesta3 = f"error: {str(e)[:50]}"
    else:
        respuesta3 = None

    resultado['respuesta_pdf1'] = respuesta1
    resultado['respuesta_pdf2'] = respuesta2
    resultado['respuesta_ocr'] = respuesta3

    return resultado

# =========================
# INTERFAZ STREAMLIT
# =========================
def main():
    st.title("üìã Analizador Comparativo de P√≥lizas + OCR")
    st.markdown("""
    **Sube 2 p√≥lizas de seguros (PDF) y un archivo Excel con preguntas para comparar respuestas.**

    ‚ú® **NUEVO**: El sistema detecta autom√°ticamente PDFs escaneados y aplica OCR antes del an√°lisis AI.
    """)

    # Inicializar cliente Mistral
    client = inicializar_mistral()
    if not client:
        return

    # Sidebar para configuraci√≥n
    with st.sidebar:
        st.header("‚öôÔ∏è Configuraci√≥n")
        st.markdown("---")

        global PAUSA_ENTRE_CONSULTAS
        PAUSA_ENTRE_CONSULTAS = st.slider("Pausa entre consultas (segundos)", 0.1, 2.0, 0.5, 0.1)

        st.markdown("---")
        st.subheader("üñºÔ∏è PDF Escaneado (OCR)")
        st.info("Opcional: Sube un PDF escaneado (imagen) para an√°lisis adicional. El sistema aplicar√° OCR autom√°ticamente.")

        st.markdown("---")
        st.info("""
        **Instrucciones:**
        1. Sube 2 archivos PDF (p√≥lizas a comparar)
        2. Opcional: Sube PDF escaneado para OCR
        3. Sube 1 archivo Excel con preguntas
        4. Haz clic en 'Procesar'
        5. Descarga el resultado con respuestas en columnas G, H e I
        """)

        st.markdown("---")
        st.caption("Desarrollado para an√°lisis de p√≥lizas de seguros")

    # Contenedor principal para upload
    st.subheader("üì§ Subir Archivos")
    col1, col2, col3 = st.columns(3)

    with col1:
        st.markdown("#### üìÑ P√≥liza 1")
        pdf1_file = st.file_uploader("Primera p√≥liza", type=["pdf"], key="pdf1", label_visibility="collapsed")
        if pdf1_file:
            st.success(f"‚úÖ {pdf1_file.name}")

    with col2:
        st.markdown("#### üìÑ P√≥liza 2")
        pdf2_file = st.file_uploader("Segunda p√≥liza", type=["pdf"], key="pdf2", label_visibility="collapsed")
        if pdf2_file:
            st.success(f"‚úÖ {pdf2_file.name}")

    with col3:
        st.markdown("#### üñºÔ∏è PDF Escaneado (OCR)")
        pdf3_file = st.file_uploader("PDF escaneado para OCR", type=["pdf"], key="pdf3", label_visibility="collapsed")
        if pdf3_file:
            st.warning(f"‚ö†Ô∏è {pdf3_file.name} - Se aplicar√° OCR antes del an√°lisis")

    st.markdown("---")
    st.subheader("üìä Archivo Excel con preguntas")
    excel_file = st.file_uploader("Excel con preguntas", type=["xlsx"], key="excel", label_visibility="visible")
    if excel_file:
        st.success(f"‚úÖ {excel_file.name}")

    # Bot√≥n de procesamiento
    if st.button("üöÄ Iniciar Procesamiento Comparativo + OCR", type="primary", use_container_width=True):
        if not all([pdf1_file, pdf2_file, excel_file]):
            st.error("‚ùå Por favor, sube al menos los 2 PDFs principales y el Excel.")
            return

        try:
            # Crear directorio temporal
            with tempfile.TemporaryDirectory() as tmpdir:
                # Guardar archivos subidos temporalmente
                pdf1_path = os.path.join(tmpdir, "poliza_1.pdf")
                pdf2_path = os.path.join(tmpdir, "poliza_2.pdf")
                excel_path = os.path.join(tmpdir, "preguntas.xlsx")

                with open(pdf1_path, "wb") as f:
                    f.write(pdf1_file.getbuffer())
                with open(pdf2_path, "wb") as f:
                    f.write(pdf2_file.getbuffer())
                with open(excel_path, "wb") as f:
                    f.write(excel_file.getbuffer())

                # ‚úÖ OCR: Guardar PDF 3 si existe
                pdf3_path = None
                usar_ocr = False
                if pdf3_file:
                    pdf3_path = os.path.join(tmpdir, "poliza_ocr.pdf")
                    with open(pdf3_path, "wb") as f:
                        f.write(pdf3_file.getbuffer())
                    usar_ocr = True

                # 1. Cargar Excel
                with st.spinner("üìä Cargando Excel..."):
                    wb = load_workbook(excel_path)
                    ws = wb.active
                    vector = construir_vector(ws)
                    total_filas = len(vector)

                    if total_filas == 0:
                        st.error("‚ùå No se encontraron filas para procesar en el Excel.")
                        return

                    st.info(f"üìã Se procesar√°n {total_filas} filas del Excel")

                # 2. Preparar PDF 1
                with st.spinner(f"üìÑ Procesando {pdf1_file.name}..."):
                    chunks1, embeddings1 = preparar_documento(pdf1_path, client)
                    st.success(f"‚úÖ P√≥liza 1 preparada: {len(chunks1)} chunks")

                # 3. Preparar PDF 2
                with st.spinner(f"üìÑ Procesando {pdf2_file.name}..."):
                    chunks2, embeddings2 = preparar_documento(pdf2_path, client)
                    st.success(f"‚úÖ P√≥liza 2 preparada: {len(chunks2)} chunks")

                # ‚úÖ OCR: Preparar documento OCR si existe
                chunks_ocr, embeddings_ocr = None, np.array([])
                if usar_ocr:
                    with st.spinner(f"üñºÔ∏è Aplicando OCR a {pdf3_file.name}..."):
                        chunks_ocr, embeddings_ocr = preparar_documento(pdf3_path, client)
                        st.success(f"‚úÖ OCR completado: {len(chunks_ocr)} chunks extra√≠dos")

                # 4. Procesar filas
                st.subheader("üîÑ Procesando consultas en los documentos...")
                progress_bar = st.progress(0)
                status_text = st.empty()

                resultados = []
                inicio_proc = time.time()

                for i, (fila, texto_consulta) in enumerate(vector, 1):
                    # Control de velocidad
                    if i > 1:
                        time.sleep(PAUSA_ENTRE_CONSULTAS)

                    # Actualizar progreso
                    progreso = i / total_filas
                    progress_bar.progress(progreso)
                    status_text.text(f"Fila {i}/{total_filas}: {texto_consulta[:50]}...")

                    # Procesar consulta en ambos PDFs + OCR si aplica
                    resultado = procesar_consulta_dual(
                        fila, texto_consulta,
                        chunks1, embeddings1,
                        chunks2, embeddings2,
                        chunks_ocr, embeddings_ocr,
                        client,
                        usar_ocr
                    )

                    resultados.append(resultado)

                tiempo_proc = time.time() - inicio_proc

                # 5. Guardar resultados
                with st.spinner("üíæ Guardando resultados en Excel..."):
                    # Escribir encabezados en la fila anterior
                    ws.cell(row=FILA_INICIO-1, column=COL_F, value="DOCUMENTO")
                    ws.cell(row=FILA_INICIO-1, column=COL_G, value=pdf1_file.name.replace(".pdf", ""))
                    ws.cell(row=FILA_INICIO-1, column=COL_H, value=pdf2_file.name.replace(".pdf", ""))

                    if usar_ocr:
                        ws.cell(row=FILA_INICIO-1, column=COL_I, value="OCR: " + pdf3_file.name.replace(".pdf", ""))

                    # Escribir respuestas
                    for r in resultados:
                        escribir_en_celda(ws, r['fila'], COL_G, r['respuesta_pdf1'])
                        escribir_en_celda(ws, r['fila'], COL_H, r['respuesta_pdf2'])
                        if usar_ocr and r['respuesta_ocr']:
                            escribir_en_celda(ws, r['fila'], COL_I, r['respuesta_ocr'])

                    # Guardar archivo resultante
                    output_path = os.path.join(tmpdir, "resultados_comparacion_ocr.xlsx")
                    wb.save(output_path)

                # 6. Mostrar resumen
                st.success("‚úÖ Procesamiento completado!")

                # Calcular estad√≠sticas
                contadores_pdf1 = {'encontrado': 0, 'no_encontrado': 0, 'error': 0}
                contadores_pdf2 = {'encontrado': 0, 'no_encontrado': 0, 'error': 0}
                contadores_ocr = {'encontrado': 0, 'no_encontrado': 0, 'error': 0} if usar_ocr else None

                for r in resultados:
                    # PDF 1
                    if "no encontrado" in str(r['respuesta_pdf1']).lower():
                        contadores_pdf1['no_encontrado'] += 1
                    elif "error" in str(r['respuesta_pdf1']).lower():
                        contadores_pdf1['error'] += 1
                    else:
                        contadores_pdf1['encontrado'] += 1

                    # PDF 2
                    if "no encontrado" in str(r['respuesta_pdf2']).lower():
                        contadores_pdf2['no_encontrado'] += 1
                    elif "error" in str(r['respuesta_pdf2']).lower():
                        contadores_pdf2['error'] += 1
                    else:
                        contadores_pdf2['encontrado'] += 1

                    # OCR
                    if usar_ocr and r['respuesta_ocr']:
                        if "no encontrado" in str(r['respuesta_ocr']).lower():
                            contadores_ocr['no_encontrado'] += 1
                        elif "error" in str(r['respuesta_ocr']).lower():
                            contadores_ocr['error'] += 1
                        else:
                            contadores_ocr['encontrado'] += 1

                # Mostrar m√©tricas
                st.subheader("üìä Resumen Comparativo")
                cols = st.columns(3 if not usar_ocr else 4)

                with cols[0]:
                    st.metric("‚è±Ô∏è Tiempo total", f"{tiempo_proc:.1f}s")
                    velocidad = (total_filas / tiempo_proc) * 60 if tiempo_proc > 0 else 0
                    st.metric("üìà Velocidad", f"{velocidad:.1f} filas/min")

                with cols[1]:
                    st.metric(f"üìÑ {pdf1_file.name[:15]}...",
                             f"{contadores_pdf1['encontrado']}/{total_filas}")
                    st.metric("üìä √âxito", f"{contadores_pdf1['encontrado']/total_filas*100:.1f}%")

                with cols[2]:
                    st.metric(f"üìÑ {pdf2_file.name[:15]}...",
                             f"{contadores_pdf2['encontrado']}/{total_filas}")
                    st.metric("üìä √âxito", f"{contadores_pdf2['encontrado']/total_filas*100:.1f}%")

                if usar_ocr and contadores_ocr:
                    with cols[3]:
                        st.metric("üñºÔ∏è OCR",
                                 f"{contadores_ocr['encontrado']}/{total_filas}")
                        st.metric("üìä √âxito", f"{contadores_ocr['encontrado']/total_filas*100:.1f}%")

                # Mostrar tabla de resultados
                st.subheader("üìã Resultados Detallados (primeras 10 filas)")
                df_data = []
                for r in resultados[:10]:
                    row = {
                        'Fila': r['fila'],
                        'Consulta': r['consulta'][:80] + "..." if len(r['consulta']) > 80 else r['consulta'],
                        pdf1_file.name[:15] + "...": r['respuesta_pdf1'][:80] + "..." if len(r['respuesta_pdf1']) > 80 else r['respuesta_pdf1'],
                        pdf2_file.name[:15] + "...": r['respuesta_pdf2'][:80] + "..." if len(r['respuesta_pdf2']) > 80 else r['respuesta_pdf2']
                    }
                    if usar_ocr and r['respuesta_ocr']:
                        row['OCR'] = r['respuesta_ocr'][:80] + "..." if len(r['respuesta_ocr']) > 80 else r['respuesta_ocr']
                    df_data.append(row)

                df_resultados = pd.DataFrame(df_data)
                st.dataframe(df_resultados, use_container_width=True)

                # Bot√≥n de descarga
                with open(output_path, "rb") as f:
                    st.download_button(
                        label="üì• Descargar Excel con resultados (incluye OCR)",
                        data=f,
                        file_name=f"comparacion_{pdf1_file.name.split('.')[0]}_vs_{pdf2_file.name.split('.')[0]}_ocr.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        type="primary",
                        use_container_width=True
                    )

                # Limpiar caches
                embeddings_cache_pdf1.clear()
                embeddings_cache_pdf2.clear()
                embeddings_cache_ocr.clear()

        except Exception as e:
            st.error(f"‚ùå Error durante el procesamiento: {str(e)}")
            st.exception(e)

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
